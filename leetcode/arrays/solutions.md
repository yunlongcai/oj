# 题解

[TOC]

## 一、删除排序数组中的重复项

给定一个排序数组，你需要在 `原地` 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 `原地` 修改输入数组 并在使用 `O(1)` 额外空间的条件下完成。

> 基本思路

因为是已经排序好的，所以之前出现的过数字只会连续出现，不会重复在后面重复出现。 

可以使用快慢指针的方式，一个指针遍历数组，另一个指针记录未重复出现数字的在原数组的位置。

快指针遍历完数组则结束

慢指针在遇到与当前值不一样的数字时，将该数字记录到当前位置，并向前移动一步。

```go
func removeDuplicates(nums []int) int {
	if len(nums) == 0 {
		return 0
	}
	curVal := nums[0]
	curPos := 1
	for i := 1; i < len(nums); i++ {
		if curVal == nums[i] {
			continue
		}
		nums[curPos] = nums[i]
		curVal = nums[i]
		curPos++
	}
	return curPos
}
```

## 只出现过一次的数字

利用异或的特性, 异或自身等于 0， 异或 0 值不变。 异或所有的数字即可得出唯一一个没有重复的数字。

```
a ^ a = 0
b ^ 0 = b
```


## 旋转数组


## 移动零

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。

> 基本思路

双指针方式，一个指针记录当前放置非0数字的下标，另一个指针按顺序遍历数组，遇到非0的则跟当前放置非0数字的位置的0，进行交换；交换时，第一个指针向前一步。

0 本身是无序的。不需要考虑。

```go
func moveZeroes(nums []int) {
	//cur 表示下个放置非 0 数字的位置
	cur := 0
	for i := 0; i < len(nums); i++ {
		if nums[i] != 0 {
			if cur != i {
				nums[cur], nums[i] = nums[i], nums[cur]
			}
			cur++
		}
	}
}
```
